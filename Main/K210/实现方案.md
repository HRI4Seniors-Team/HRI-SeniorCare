## 总体方案

1. K210端用来计算声源角度并通过串口发出，esp32解析串口接受的角度数据，映射到两个舵机上(X/Y轴)

2. K210发送的数据格式：

由只有水平角度 -> 水平 + 俯仰

```makefile
X:角度1,Y:角度2,STRENGTH:强度\r\n
```

esp32 只需要解析 `ANGLE:xxx`，把角度值转为对应的舵机角度

## 云台映射方案

1. K210 端需要输出水平角度和俯仰角度
2. ESP32 端接收两个角度，通过舵机分别控制云台的水平和抚养

## 对接和使用

1. 硬件连接

- K210 TX → ESP32 RXD（GPIO16）
- SG90信号分别接18、19脚
- 电源独立，GND共地

2. 编译和烧录（esp-idf）
3. 串口输出
- K210端每100ms发一次X:xxx,Y:xxx,STRENGTH:xxx
- ESP32自动控制云台舵机跟随


## 如何测试

### 硬件连线

1. 舵机SG90

- 红色线接5V电源（推荐独立5V，勿直接由ESP32供电）

- 棕色线接GND（和ESP32、K210必须共地！）

- 橙色线（信号）分别接ESP32的18、19（假设主控用的就是18、19）

2. ESP32与K210串口连接

- K210的TX → ESP32的RX2（GPIO16）

- 两者GND也要连接在一起

- ESP32的TX2（GPIO17）可不用接

### 烧录与串口监控

1. 终端编译烧录
2. 打开串口监控，观察 `ESP_LOGI()` 的输出

### 单独测试舵机转动

在 `main.c` 中加入临时代码，舵机正常会来回摆动

```cpp
#include <stdio.h>
#include "servo.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#define SERVO_X_GPIO 18
#define SERVO_Y_GPIO 19
#define SERVO_X_CHANNEL LEDC_CHANNEL_0
#define SERVO_Y_CHANNEL LEDC_CHANNEL_1

void app_main(void)
{
    servo_init(SERVO_X_GPIO, SERVO_X_CHANNEL);
    servo_init(SERVO_Y_GPIO, SERVO_Y_CHANNEL);

    while (1) {
        for (int ang = 10; ang <= 170; ang += 20) {
            servo_set_angle(SERVO_X_CHANNEL, ang);
            servo_set_angle(SERVO_Y_CHANNEL, 180 - ang);
            vTaskDelay(600 / portTICK_PERIOD_MS);
        }
    }
}

```

### 通过串口助手进行模拟k210数据


### K210 相关注意事项

- `python` 文件不能放在 `esp-idf` 编译目录下 (`main`)
- K210 相关的 py 文件放在其他任何位置均可，用 MaixPy IDE、kflash_gui 或者官方工具编译运行，通过串口通信向 esp32 发送数据